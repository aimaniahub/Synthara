/**
 * PDF Export Service
 * Generate comprehensive PDF reports for data analysis
 */

import jsPDF from 'jspdf';
import 'jspdf-autotable';
import { ChartData, processChartsForPDF } from '@/lib/chart-to-image';

// Extend jsPDF type to include autoTable
declare module 'jspdf' {
  interface jsPDF {
    autoTable: (options: any) => jsPDF;
    lastAutoTable: {
      finalY: number;
    };
  }
}

export interface PDFExportOptions {
  datasetName: string;
  analysisDate: string;
  profile: any;
  insights: any;
  charts?: ChartData[];
  rawData?: any[];
}

export class PDFExportService {
  private doc: jsPDF;
  private currentY: number = 30;

  constructor() {
    this.doc = new jsPDF();
  }

  /**
   * Generate comprehensive analysis report
   */
  async generateReport(options: PDFExportOptions): Promise<Blob> {
    const { datasetName, analysisDate, profile, insights, charts, rawData } = options;
    
    // Reset document
    this.doc = new jsPDF();
    this.currentY = 30;
    
    // Add header
    this.addHeader(datasetName, analysisDate);
    
    // Add table of contents
    this.addTableOfContents();
    
    // Add executive summary
    this.addExecutiveSummary(profile);
    
    // Add dataset overview
    this.addDatasetOverview(profile);
    
    // Add statistical summary
    this.addStatisticalSummary(profile);
    
    // Add data quality analysis
    this.addDataQualityAnalysis(profile);
    
    // Add column analysis
    this.addColumnAnalysis(profile);
    
    // Add correlation analysis
    this.addCorrelationAnalysis(profile);
    
    // Add AI insights
    this.addAIInsights(insights);
    
    // Add charts and visualizations
    if (charts && charts.length > 0) {
      await this.addCharts(charts);
    }
    
    // Add recommendations
    this.addRecommendations(insights);
    
    // Add sample data
    if (rawData && rawData.length > 0) {
      this.addSampleData(rawData);
    }
    
    // Add footer
    this.addFooter();
    
    return this.doc.output('blob');
  }

  private addHeader(datasetName: string, analysisDate: string) {
    // Title
    this.doc.setFontSize(24);
    this.doc.setFont('helvetica', 'bold');
    this.doc.text('Data Analysis Report', 20, 30);
    
    // Dataset info
    this.doc.setFontSize(14);
    this.doc.setFont('helvetica', 'normal');
    this.doc.text(`Dataset: ${datasetName}`, 20, 45);
    this.doc.text(`Analysis Date: ${analysisDate}`, 20, 55);
    
    // Synthara branding
    this.doc.setFontSize(10);
    this.doc.setTextColor(100, 100, 100);
    this.doc.text('Generated by Synthara AI', 20, 65);
    
    // Reset text color
    this.doc.setTextColor(0, 0, 0);
  }

  private addTableOfContents() {
    this.doc.addPage();
    this.currentY = 30;
    
    this.doc.setFontSize(18);
    this.doc.setFont('helvetica', 'bold');
    this.doc.text('Table of Contents', 20, this.currentY);
    this.currentY += 20;
    
    this.doc.setFontSize(12);
    this.doc.setFont('helvetica', 'normal');
    
    const tocItems = [
      'Executive Summary',
      'Dataset Overview',
      'Statistical Summary',
      'Data Quality Analysis',
      'Column Analysis',
      'Correlation Analysis',
      'AI Insights & Recommendations',
      'Data Visualizations',
      'Sample Data'
    ];
    
    tocItems.forEach((item, index) => {
      this.doc.text(`${index + 1}. ${item}`, 20, this.currentY);
      this.currentY += 10;
    });
  }

  private addExecutiveSummary(profile: any) {
    this.doc.addPage();
    this.currentY = 30;
    
    this.doc.setFontSize(16);
    this.doc.setFont('helvetica', 'bold');
    this.doc.text('Executive Summary', 20, this.currentY);
    this.currentY += 20;
    
    this.doc.setFontSize(12);
    this.doc.setFont('helvetica', 'normal');
    
    const summary = [
      `This comprehensive data analysis report covers a dataset containing ${profile.totalRows.toLocaleString()} rows and ${profile.totalColumns} columns.`,
      `The overall data quality score is ${profile.overallQuality.toFixed(1)}%, indicating ${this.getQualityDescription(profile.overallQuality)}.`,
      `The dataset includes ${profile.numericColumns.length} numeric columns and ${profile.categoricalColumns.length} categorical columns.`,
      profile.missingDataPattern.length > 0 
        ? `${profile.missingDataPattern.length} columns have missing data that may require attention.`
        : 'No significant missing data issues were detected.',
      profile.numericColumns.length > 1
        ? 'Correlation analysis reveals relationships between numeric variables.'
        : 'Single numeric column detected - correlation analysis not applicable.'
    ];
    
    summary.forEach((line, index) => {
      this.doc.text(line, 20, this.currentY);
      this.currentY += 15;
    });
  }

  private addDatasetOverview(profile: any) {
    this.doc.addPage();
    this.currentY = 30;
    
    this.doc.setFontSize(16);
    this.doc.setFont('helvetica', 'bold');
    this.doc.text('Dataset Overview', 20, this.currentY);
    this.currentY += 20;
    
    // Basic statistics table
    const overviewData = [
      ['Metric', 'Value'],
      ['Total Rows', profile.totalRows.toLocaleString()],
      ['Total Columns', profile.totalColumns.toString()],
      ['Data Quality Score', `${profile.overallQuality.toFixed(1)}%`],
      ['Numeric Columns', profile.numericColumns.length.toString()],
      ['Categorical Columns', profile.categoricalColumns.length.toString()],
      ['Columns with Missing Data', profile.missingDataPattern.length.toString()],
      ['Average Missing Data', `${this.calculateAverageMissingData(profile).toFixed(1)}%`]
    ];
    
    // Check if autoTable is available
    if (typeof (this.doc as any).autoTable === 'function') {
      this.doc.autoTable({
        head: [overviewData[0]],
        body: overviewData.slice(1),
        startY: this.currentY,
        theme: 'grid',
        headStyles: { fillColor: [59, 130, 246] },
        styles: { fontSize: 10 }
      });
      
      this.currentY = this.doc.lastAutoTable.finalY + 20;
    } else {
      // Fallback: create a simple table manually
      this.addSimpleTable(overviewData, this.currentY);
      this.currentY += 100;
    }
  }

  private addStatisticalSummary(profile: any) {
    this.doc.addPage();
    this.currentY = 30;
    
    this.doc.setFontSize(16);
    this.doc.setFont('helvetica', 'bold');
    this.doc.text('Statistical Summary', 20, this.currentY);
    this.currentY += 20;
    
    // Column details table
    if (profile.columns.length > 0) {
      const columnData = profile.columns.map((col: any) => [
        col.name,
        col.type,
        col.count.toString(),
        `${col.missingPercentage.toFixed(1)}%`,
        col.unique.toString(),
        col.type === 'numeric' && col.mean ? col.mean.toFixed(2) : '-',
        col.type === 'numeric' && col.std ? col.std.toFixed(2) : '-'
      ]);
      
      if (typeof (this.doc as any).autoTable === 'function') {
        this.doc.autoTable({
          head: [['Column', 'Type', 'Count', 'Missing %', 'Unique', 'Mean', 'Std Dev']],
          body: columnData,
          startY: this.currentY,
          theme: 'grid',
          headStyles: { fillColor: [59, 130, 246] },
          styles: { fontSize: 9 }
        });
        
        this.currentY = this.doc.lastAutoTable.finalY + 20;
      } else {
        this.addSimpleTable([['Column', 'Type', 'Count', 'Missing %', 'Unique', 'Mean', 'Std Dev'], ...columnData], this.currentY);
        this.currentY += 150;
      }
    }
  }

  private addDataQualityAnalysis(profile: any) {
    this.doc.addPage();
    this.currentY = 30;
    
    this.doc.setFontSize(16);
    this.doc.setFont('helvetica', 'bold');
    this.doc.text('Data Quality Analysis', 20, this.currentY);
    this.currentY += 20;
    
    this.doc.setFontSize(12);
    this.doc.setFont('helvetica', 'normal');
    
    // Quality score interpretation
    const qualityInterpretation = this.getQualityDescription(profile.overallQuality);
    this.doc.text(`Overall Quality Assessment: ${qualityInterpretation}`, 20, this.currentY);
    this.currentY += 15;
    
    // Missing data details
    if (profile.missingDataPattern.length > 0) {
      this.doc.setFontSize(14);
      this.doc.setFont('helvetica', 'bold');
      this.doc.text('Missing Data Details', 20, this.currentY);
      this.currentY += 15;
      
      const missingData = profile.missingDataPattern.map((item: any) => [
        item.column,
        item.missingCount.toString(),
        `${item.missingPercentage.toFixed(1)}%`,
        this.getMissingDataSeverity(item.missingPercentage)
      ]);
      
      if (typeof (this.doc as any).autoTable === 'function') {
        this.doc.autoTable({
          head: [['Column', 'Missing Count', 'Missing %', 'Severity']],
          body: missingData,
          startY: this.currentY,
          theme: 'grid',
          headStyles: { fillColor: [239, 68, 68] },
          styles: { fontSize: 10 }
        });
        
        this.currentY = this.doc.lastAutoTable.finalY + 20;
      } else {
        this.addSimpleTable([['Column', 'Missing Count', 'Missing %', 'Severity'], ...missingData], this.currentY);
        this.currentY += 100;
      }
    } else {
      this.doc.text('✓ No missing data detected in any columns', 20, this.currentY);
      this.currentY += 15;
    }
  }

  private addColumnAnalysis(profile: any) {
    this.doc.addPage();
    this.currentY = 30;
    
    this.doc.setFontSize(16);
    this.doc.setFont('helvetica', 'bold');
    this.doc.text('Detailed Column Analysis', 20, this.currentY);
    this.currentY += 20;
    
    // Analyze each column in detail
    for (const column of profile.columns) {
      this.doc.setFontSize(14);
      this.doc.setFont('helvetica', 'bold');
      this.doc.text(`Column: ${column.name} (${column.type})`, 20, this.currentY);
      this.currentY += 15;
      
      this.doc.setFontSize(10);
      this.doc.setFont('helvetica', 'normal');
      
      // Basic stats
      const basicStats = [
        ['Count', column.count.toString()],
        ['Missing', column.missing.toString()],
        ['Missing %', `${column.missingPercentage.toFixed(1)}%`],
        ['Unique Values', column.unique.toString()],
        ['Completeness', `${(100 - column.missingPercentage).toFixed(1)}%`]
      ];
      
      if (typeof (this.doc as any).autoTable === 'function') {
        this.doc.autoTable({
          head: [['Metric', 'Value']],
          body: basicStats,
          startY: this.currentY,
          theme: 'grid',
          headStyles: { fillColor: [34, 197, 94] },
          styles: { fontSize: 9 }
        });
        
        this.currentY = this.doc.lastAutoTable.finalY + 15;
      } else {
        this.addSimpleTable([['Metric', 'Value'], ...basicStats], this.currentY);
        this.currentY += 80;
      }
      
      // Numeric specific stats
      if (column.type === 'numeric' && column.mean !== undefined) {
        const numericStats = [
          ['Mean', column.mean.toFixed(2)],
          ['Median', column.median?.toFixed(2) || 'N/A'],
          ['Standard Deviation', column.std?.toFixed(2) || 'N/A'],
          ['Minimum', column.min?.toFixed(2) || 'N/A'],
          ['Maximum', column.max?.toFixed(2) || 'N/A'],
          ['Q1 (25th percentile)', column.q1?.toFixed(2) || 'N/A'],
          ['Q3 (75th percentile)', column.q3?.toFixed(2) || 'N/A'],
          ['Outliers', column.outliers?.length?.toString() || '0']
        ];
        
        if (typeof (this.doc as any).autoTable === 'function') {
          this.doc.autoTable({
            head: [['Statistical Measure', 'Value']],
            body: numericStats,
            startY: this.currentY,
            theme: 'grid',
            headStyles: { fillColor: [168, 85, 247] },
            styles: { fontSize: 9 }
          });
          
          this.currentY = this.doc.lastAutoTable.finalY + 15;
        } else {
          this.addSimpleTable([['Statistical Measure', 'Value'], ...numericStats], this.currentY);
          this.currentY += 120;
        }
      }
      
      // Categorical specific stats
      if (column.type === 'categorical' && column.topValues && column.topValues.length > 0) {
        this.doc.setFontSize(12);
        this.doc.setFont('helvetica', 'bold');
        this.doc.text('Top Values:', 20, this.currentY);
        this.currentY += 10;
        
        const topValuesData = column.topValues.slice(0, 10).map((item: any) => [
          item.value.toString(),
          item.count.toString(),
          `${item.percentage.toFixed(1)}%`
        ]);
        
        if (typeof (this.doc as any).autoTable === 'function') {
          this.doc.autoTable({
            head: [['Value', 'Count', 'Percentage']],
            body: topValuesData,
            startY: this.currentY,
            theme: 'grid',
            headStyles: { fillColor: [245, 158, 11] },
            styles: { fontSize: 9 }
          });
          
          this.currentY = this.doc.lastAutoTable.finalY + 15;
        } else {
          this.addSimpleTable([['Value', 'Count', 'Percentage'], ...topValuesData], this.currentY);
          this.currentY += 150;
        }
      }
      
      this.currentY += 10;
      
      // Check if we need a new page
      if (this.currentY > 250) {
        this.doc.addPage();
        this.currentY = 30;
      }
    }
  }

  private addCorrelationAnalysis(profile: any) {
    if (!profile.correlationMatrix || profile.numericColumns.length < 2) {
      return;
    }
    
    this.doc.addPage();
    this.currentY = 30;
    
    this.doc.setFontSize(16);
    this.doc.setFont('helvetica', 'bold');
    this.doc.text('Correlation Analysis', 20, this.currentY);
    this.currentY += 20;
    
    this.doc.setFontSize(12);
    this.doc.setFont('helvetica', 'normal');
    this.doc.text('Correlation matrix for numeric variables:', 20, this.currentY);
    this.currentY += 15;
    
    // Create correlation matrix table
    const correlationData = profile.correlationMatrix.map((row: number[], i: number) => {
      const rowData = [profile.numericColumns[i]];
      row.forEach(corr => {
        rowData.push(corr.toFixed(3));
      });
      return rowData;
    });
    
    if (typeof (this.doc as any).autoTable === 'function') {
      this.doc.autoTable({
        head: ['', ...profile.numericColumns],
        body: correlationData,
        startY: this.currentY,
        theme: 'grid',
        headStyles: { fillColor: [59, 130, 246] },
        styles: { fontSize: 8 }
      });
      
      this.currentY = this.doc.lastAutoTable.finalY + 20;
    } else {
      this.addSimpleTable([['', ...profile.numericColumns], ...correlationData], this.currentY);
      this.currentY += 200;
    }
    
    // Add correlation insights
    this.doc.setFontSize(12);
    this.doc.setFont('helvetica', 'bold');
    this.doc.text('Key Correlations:', 20, this.currentY);
    this.currentY += 10;
    
    const correlations = this.findSignificantCorrelations(profile.correlationMatrix, profile.numericColumns);
    correlations.forEach(corr => {
      this.doc.setFontSize(10);
      this.doc.setFont('helvetica', 'normal');
      this.doc.text(`• ${corr.col1} ↔ ${corr.col2}: ${corr.strength} (${corr.value.toFixed(3)})`, 25, this.currentY);
      this.currentY += 8;
    });
  }

  private addAIInsights(insights: any) {
    this.doc.addPage();
    this.currentY = 30;
    
    this.doc.setFontSize(16);
    this.doc.setFont('helvetica', 'bold');
    this.doc.text('AI Insights & Analysis', 20, this.currentY);
    this.currentY += 20;
    
    // Column insights
    if (insights.columnInsights && insights.columnInsights.length > 0) {
      this.doc.setFontSize(14);
      this.doc.setFont('helvetica', 'bold');
      this.doc.text('Column Insights', 20, this.currentY);
      this.currentY += 15;
      
      insights.columnInsights.forEach((insight: any) => {
        this.doc.setFontSize(12);
        this.doc.setFont('helvetica', 'bold');
        this.doc.text(`${insight.column} (${insight.quality}% quality)`, 20, this.currentY);
        this.currentY += 10;
        
        this.doc.setFont('helvetica', 'normal');
        this.doc.text(insight.semanticMeaning, 20, this.currentY);
        this.currentY += 10;
        
        if (insight.suggestions && insight.suggestions.length > 0) {
          this.doc.text('Suggestions:', 20, this.currentY);
          this.currentY += 8;
          
          insight.suggestions.forEach((suggestion: string) => {
            this.doc.text(`• ${suggestion}`, 25, this.currentY);
            this.currentY += 8;
          });
        }
        
        this.currentY += 10;
      });
    }
    
    // Deep insights
    if (insights.deepInsights) {
      const deep = insights.deepInsights;
      
      if (deep.patterns && deep.patterns.length > 0) {
        this.doc.setFontSize(14);
        this.doc.setFont('helvetica', 'bold');
        this.doc.text('Patterns & Trends', 20, this.currentY);
        this.currentY += 15;
        
        deep.patterns.forEach((pattern: string) => {
          this.doc.setFontSize(12);
          this.doc.setFont('helvetica', 'normal');
          this.doc.text(`• ${pattern}`, 20, this.currentY);
          this.currentY += 8;
        });
        
        this.currentY += 10;
      }
      
      if (deep.anomalies && deep.anomalies.length > 0) {
        this.doc.setFontSize(14);
        this.doc.setFont('helvetica', 'bold');
        this.doc.text('Anomalies & Outliers', 20, this.currentY);
        this.currentY += 15;
        
        deep.anomalies.forEach((anomaly: string) => {
          this.doc.setFontSize(12);
          this.doc.setFont('helvetica', 'normal');
          this.doc.text(`• ${anomaly}`, 20, this.currentY);
          this.currentY += 8;
        });
        
        this.currentY += 10;
      }
    }
  }

  private addRecommendations(insights: any) {
    this.doc.addPage();
    this.currentY = 30;
    
    this.doc.setFontSize(16);
    this.doc.setFont('helvetica', 'bold');
    this.doc.text('Recommendations', 20, this.currentY);
    this.currentY += 20;
    
    this.doc.setFontSize(12);
    this.doc.setFont('helvetica', 'normal');
    
    const recommendations = [
      'Review and address missing data in identified columns',
      'Consider data validation rules for future data collection',
      'Explore correlations between numeric variables for insights',
      'Standardize categorical values for consistency',
      'Consider feature engineering based on AI insights',
      'Implement data quality monitoring processes',
      'Document data collection procedures for consistency'
    ];
    
    if (insights.deepInsights && insights.deepInsights.recommendations) {
      recommendations.push(...insights.deepInsights.recommendations);
    }
    
    recommendations.forEach((rec, index) => {
      this.doc.text(`${index + 1}. ${rec}`, 20, this.currentY);
      this.currentY += 10;
    });
  }

  private async addCharts(charts: ChartData[]) {
    this.doc.addPage();
    this.currentY = 30;
    
    this.doc.setFontSize(16);
    this.doc.setFont('helvetica', 'bold');
    this.doc.text('Data Visualizations', 20, this.currentY);
    this.currentY += 20;
    
    // Process charts to get image data
    const processedCharts = await processChartsForPDF(charts, {
      width: 400,
      height: 300,
      quality: 0.8
    });
    
    for (const chart of processedCharts) {
      // Chart title
      this.doc.setFontSize(14);
      this.doc.setFont('helvetica', 'bold');
      this.doc.text(chart.title, 20, this.currentY);
      this.currentY += 15;
      
      // Chart image
      if (chart.imageData) {
        try {
          // Add image to PDF
          const imgWidth = 150;
          const imgHeight = 100;
          
          this.doc.addImage(
            chart.imageData,
            'PNG',
            20,
            this.currentY,
            imgWidth,
            imgHeight
          );
          
          this.currentY += imgHeight + 20;
        } catch (error) {
          console.warn(`Failed to add chart image for "${chart.title}":`, error);
          this.doc.setFontSize(10);
          this.doc.setFont('helvetica', 'normal');
          this.doc.text('Chart visualization not available', 20, this.currentY);
          this.currentY += 20;
        }
      }
      
      // Check if we need a new page
      if (this.currentY > 200) {
        this.doc.addPage();
        this.currentY = 30;
      }
    }
  }

  private addSampleData(rawData: any[]) {
    this.doc.addPage();
    this.currentY = 30;
    
    this.doc.setFontSize(16);
    this.doc.setFont('helvetica', 'bold');
    this.doc.text('Sample Data', 20, this.currentY);
    this.currentY += 20;
    
    this.doc.setFontSize(10);
    this.doc.setFont('helvetica', 'normal');
    this.doc.text(`Showing first ${Math.min(20, rawData.length)} rows of the dataset:`, 20, this.currentY);
    this.currentY += 15;
    
    // Get column headers
    const headers = Object.keys(rawData[0]);
    const sampleData = rawData.slice(0, 20).map(row => 
      headers.map(header => {
        const value = row[header];
        if (value === null || value === undefined) return 'N/A';
        if (typeof value === 'string' && value.length > 20) return value.substring(0, 17) + '...';
        return value.toString();
      })
    );
    
    if (typeof (this.doc as any).autoTable === 'function') {
      this.doc.autoTable({
        head: [headers],
        body: sampleData,
        startY: this.currentY,
        theme: 'grid',
        headStyles: { fillColor: [59, 130, 246] },
        styles: { fontSize: 8 }
      });
    } else {
      this.addSimpleTable([headers, ...sampleData], this.currentY);
    }
  }

  private addSimpleTable(data: string[][], startY: number) {
    if (!data || data.length === 0) return;
    
    const cellHeight = 8;
    const cellPadding = 4;
    const maxWidth = 170;
    const colWidth = maxWidth / data[0].length;
    
    // Draw table border
    this.doc.setDrawColor(200, 200, 200);
    this.doc.rect(20, startY, maxWidth, data.length * cellHeight + cellPadding);
    
    // Draw header background
    this.doc.setFillColor(240, 240, 240);
    this.doc.rect(20, startY, maxWidth, cellHeight + cellPadding, 'F');
    
    // Draw rows
    data.forEach((row, rowIndex) => {
      const y = startY + (rowIndex * cellHeight) + cellPadding;
      
      // Draw column separators
      for (let i = 1; i < data[0].length; i++) {
        const x = 20 + (i * colWidth);
        this.doc.line(x, startY, x, startY + (data.length * cellHeight) + cellPadding);
      }
      
      // Draw row separator
      if (rowIndex > 0) {
        this.doc.line(20, y - cellPadding/2, 20 + maxWidth, y - cellPadding/2);
      }
      
      // Draw cell content
      row.forEach((cell, colIndex) => {
        const x = 20 + (colIndex * colWidth) + 2;
        const cellText = cell.length > 15 ? cell.substring(0, 12) + '...' : cell;
        
        this.doc.setFontSize(8);
        this.doc.setFont('helvetica', rowIndex === 0 ? 'bold' : 'normal');
        this.doc.text(cellText, x, y);
      });
    });
  }

  private addFooter() {
    const pageCount = this.doc.getNumberOfPages();
    
    for (let i = 1; i <= pageCount; i++) {
      this.doc.setPage(i);
      
      // Footer line
      this.doc.setDrawColor(200, 200, 200);
      this.doc.line(20, 280, 190, 280);
      
      // Page number
      this.doc.setFontSize(10);
      this.doc.setTextColor(100, 100, 100);
      this.doc.text(`Page ${i} of ${pageCount}`, 20, 290);
      
      // Synthara branding
      this.doc.text('Synthara AI - Data Analysis Platform', 190, 290, { align: 'right' });
    }
  }

  // Helper methods
  private getQualityDescription(quality: number): string {
    if (quality >= 95) return 'Excellent data quality';
    if (quality >= 85) return 'Good data quality with minor issues';
    if (quality >= 70) return 'Fair data quality requiring attention';
    if (quality >= 50) return 'Poor data quality needing significant cleaning';
    return 'Very poor data quality requiring major data cleaning';
  }

  private getMissingDataSeverity(percentage: number): string {
    if (percentage === 0) return 'None';
    if (percentage < 5) return 'Low';
    if (percentage < 20) return 'Medium';
    if (percentage < 50) return 'High';
    return 'Critical';
  }

  private calculateAverageMissingData(profile: any): number {
    if (profile.columns.length === 0) return 0;
    const totalMissing = profile.columns.reduce((sum: number, col: any) => sum + col.missingPercentage, 0);
    return totalMissing / profile.columns.length;
  }

  private findSignificantCorrelations(matrix: number[][], columns: string[]): Array<{col1: string, col2: string, value: number, strength: string}> {
    const correlations = [];
    
    for (let i = 0; i < matrix.length; i++) {
      for (let j = i + 1; j < matrix[i].length; j++) {
        const value = Math.abs(matrix[i][j]);
        if (value > 0.5) { // Only show significant correlations
          let strength = 'Weak';
          if (value > 0.8) strength = 'Very Strong';
          else if (value > 0.7) strength = 'Strong';
          else if (value > 0.6) strength = 'Moderate';
          
          correlations.push({
            col1: columns[i],
            col2: columns[j],
            value: matrix[i][j],
            strength
          });
        }
      }
    }
    
    return correlations.sort((a, b) => Math.abs(b.value) - Math.abs(a.value));
  }
}

// Export singleton instance
export const pdfExportService = new PDFExportService();